<head>
        <style> body {margin: 0;} </style>
        <script src="https://unpkg.com/force-graph"></script>
        <script src=parlanetdata.js></script>
        <meta charset="UTF-8">
    </head>
    <body>
    <div id="graph"></div>
    <script>
        
        const elem = document.getElementById('graph');
        const Graph = ForceGraph()(elem)
            .graphData(data)
            .nodeId('id')
            .nodeLabel('name')
            .nodeRelSize(12)
            .nodeAutoColorBy('party')
            //.backgroundColor('#000000')
            //.linkColor(() => 'rgba(255,255,255,0.2)')
            //.linkVisibility('false')
            .linkCurvature(0.2)
            //.linkDirectionalParticles(2)
            //.linkDirectionalParticleWidth(1.4)
            .onNodeClick (node => {window.open(`wordnet.html`, '_blank')})
            //.onNodeHover(node => elem.style.cursor = node ? 'pointer' : null)
            .onNodeRightClick(node => {
                // Center/zoom on node
                Graph.centerAt(node.x, node.y, 1000);
                Graph.zoom(8, 2000);
              })
          //   .nodeCanvasObject((node, ctx, globalScale) => {
          //       const label = node.name;
          //       const fontSize = 12/globalScale;
          //       ctx.font = `${fontSize}px Sans-Serif`;
          //       const textWidth = ctx.measureText(label).width;
          //       const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2); // some padding

          //       ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          //       ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);

          //       ctx.textAlign = 'center';
          //       ctx.textBaseline = 'middle';
          //       ctx.fillStyle = node.color;
          //       ctx.fillText(label, node.x, node.y);

          //       node.__bckgDimensions = bckgDimensions; // to re-use in nodePointerAreaPaint
          //     })
          // .nodePointerAreaPaint((node, color, ctx) => {
          //       ctx.fillStyle = color;
          //       const bckgDimensions = node.__bckgDimensions;
          //       bckgDimensions && ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);               
          //     })
          //.cooldownTime(Infinity)
          // .d3AlphaDecay(0.0)
          // .d3VelocityDecay(0.0)

          // // Deactivate existing forces
          // .d3Force('center', null)
          // .d3Force('charge', null)

          // // Add collision and bounding box forces
          // .d3Force('collide', d3.forceCollide(Graph.nodeRelSize()))
          // .d3Force('box', () => {
          //   const SQUARE_HALF_SIDE = Graph.nodeRelSize() * N * 2.5;

          //   nodes.forEach(node => {
          //   const x = node.x || 0, y = node.y || 0;

          //   // bounce on box walls
          //   if (Math.abs(x) > SQUARE_HALF_SIDE) { node.vx *= -1; }
          //   if (Math.abs(y) > SQUARE_HALF_SIDE) { node.vy *= -1; }
          //   })    
          // });
    
    
    
    </script>
    </body>
    